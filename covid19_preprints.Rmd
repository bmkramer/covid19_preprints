---
title: "R Notebook"
output: github_document
---

# Load required packages 

```{r}

library(aRxiv)
library(lubridate)
library(rcrossref)
library(tidyverse)
library(rvest)
library(unikn) # colorblind friendly palette

```

# Crossref data

The first step is to harvest raw metadata of preprints indexed in Crossref. Harvesting of Crossref metadata can be easily achieved using the [rcrossref](https://github.com/ropensci/rcrossref) package for R. In general, preprints are indexed in Crossref with the 'type' field set to 'posted-content'. The `cr_types_` function can therefore be used to retrieve all metadata related to records with the type of 'posted-content', filtered for the dates of this analysis (i.e. 2020-01-01 until present). Note that here, the 'low level' `cr_types_` function is used to return all metadata in list format, as this also includes some fields (e.g. abstract) that are not returned by the 'high level' `cr_types` function.

```{r, cache = TRUE}

# Query posted content
cr_posted_content <- cr_types_(types = "posted-content",
                               works = TRUE, 
                               filter = c(from_posted_date = "2020-01-01", 
                                          until_posted_date = as.character(Sys.Date())), 
                               limit = 1000, 
                               cursor = "*",
                               parse = TRUE,
                               cursor_max = 100000)

```

Next, relevant preprint metadata fields are parsed from the list format returned in the previous step, to a more manageable data frame. Note the 'institution', 'publisher' and 'group-title' fields are retained, to be later used to match preprints to specific preprint repositories.

```{r, cache = TRUE}

# Function to parse posted date parts to more useful YYYY-MM-DD format
parsePostedDate <- function(posted) {
  if(length(posted$`date-parts`[[1]]) == 3) {
    return(format(as.Date(paste0(posted$`date-parts`[[1]][[1]], "-",
                          posted$`date-parts`[[1]][[2]], "-",
                          posted$`date-parts`[[1]][[3]]),
           "%Y-%m-%d")))
  } else  {
    return(NA)
  }
}

# Function to parse posted content to data frame
parsePreprints <- function(item) {
  tibble(
    institution = ifelse(length(item$institution$name), item$institution$name, NA),
    publisher = item$publisher,
    group_title = ifelse(length(item$`group-title`), item$`group-title`, NA),
    cr_member_id = item$member,
    doi = item$DOI,
    title = item$title[[1]],
    # For posted-content, use the 'posted' date fields for the relevant date. For
    # SSRN preprints, use the 'created' date
    posted_date = ifelse(length(item$posted), 
                         parsePostedDate(item$posted), 
                         parsePostedDate(item$created)),
    abstract = ifelse(length(item$abstract), item$abstract, NA)
  )
}

# Iterate over posted-content list and build data frame
cr_posted_content_df <- map_dfr(cr_posted_content, function(x) 
                          map_dfr(x$message$items, function(y)
                            parsePreprints(y)))

```

In the final step, preprints are subsetted to include only those related to COVID-19, and the respective preprint repository of each identified.

```{r, cache = TRUE}

# Generate a search string containing terms related to COVID-19
search_string <- "coronavirus|covid|sars-cov|ncov-2019|2019-ncov"

cr_posted_content_covid <- cr_posted_content_df %>%
  # Filter COVID-19 related preprints
  filter(str_detect(title, regex(search_string, ignore_case = TRUE)) | 
         str_detect(abstract, regex(search_string, ignore_case = TRUE))) %>%
  # Rule-based matching of preprints to repositories. For CSHL repositories, the
  # repository name (bioRxiv/medRxiv) is contained in the 'institution' field. For
  # others we can use the 'publisher' field, except for any preprint servers 
  # hosted on OSF in which we should use the 'group_title' field to ensure we get
  # the right repository.
  mutate(source = case_when(
    institution == "bioRxiv" ~ "bioRxiv",
    institution == "medRxiv" ~ "medRxiv",
    publisher == "Research Square" ~ "Research Square",
    publisher == "MDPI AG" ~ "Preprints.org",
    publisher == "American Chemical Society (ACS)" ~ "ChemRxiv",
    publisher == "JMIR Publications Inc." ~ "JMIR",
    publisher == "WHO Press" ~ "WHO",
    publisher == "ScienceOpen" ~ "ScienceOpen",
    publisher == "SAGE Publications" ~ "SAGE",
    group_title == "PsyArXiv" ~ "PsyArXiv (OSF)",
    group_title == "NutriXiv" ~ "NutriXiv (OSF)",
    group_title == "SocArXiv" ~ "SocArXiv (OSF)",
    group_title == "EdArXiv" ~ "EdArXiv (OSF)",
    group_title == "MediArXiv" ~ "MediArXiv (OSF)",
    group_title == "AfricArXiv" ~ "AfricArXiv (OSF)",
    group_title == "EarthArXiv" ~ "EarthArXiv (OSF)",
    group_title == "IndiaRxiv" ~ "IndiaRxiv (OSF)",
    group_title == "EcoEvoRxiv" ~ "EcoEvoRxiv (OSF)",
    group_title == "Open Science Framework" ~ "OSF Preprints"
  )) %>%
  # Remove those that could not be unambiguously matched
  filter(!is.na(source)) %>%
  # Some preprints have multiple DOI records relating to multiple preprint
  # versions (mainly in ChemRxiv and Preprints.org). In these cases the DOI 
  # is usually appended with a version number, e.g. 10.1000/12345.v2. To ensure
  # only a single record is counted per preprint, the version number is
  # removed and only the earliest DOI record is kept
  mutate(doi_clean = str_replace(doi, "\\.v.*|\\/v.*", "")) %>%
  group_by(doi_clean) %>%
  arrange(posted_date) %>%
  slice(1) %>%
  ungroup() %>%
  # Additionally filter preprints with the same title posted on the same server
  group_by(source, title) %>%
  arrange(posted_date) %>%
  slice(1) %>%
  ungroup() %>%
  # Select only relevant fields with unique values
  select(source, doi, posted_date, title, abstract) %>%
  distinct()

```

A side effect of the above procedure is that some preprint servers, most notably SSRN, instead index their content with the 'type' set to 'journal-article', and are thus not included when querying only for 'posted-content' types. Metadata of SSRN preprints are thus instead harvested by querying the `cr_works_` function for the ISSN of SSRN (1556-5068).

```{r}

# Query SSRN preprints
cr_ssrn <- cr_works_(filter = c(issn = "1556-5068",
                               from_created_date = "2020-01-01", 
                               until_created_date = as.character(Sys.Date())), 
                    limit = 1000,
                    cursor = "*",
                    parse = TRUE,
                    cursor_max = 100000)

# Iterate over SSRN list and build data frame
cr_ssrn_df <- map_dfr(cr_ssrn, function(x) 
                          map_dfr(x$message$items, function(y)
                            parsePreprints(y)))

```

An inspection of the published dates of SSRN preprints indicates some abnormalities, e.g. on 24th March 2020, more than 5000 SSRN preprints were published according to dates from Crossref - the next highest day only has ~250 published preprints. Manual inspection of a small number suggests that the published date in Crossref does not correspond well to the actual published date according to the SSRN website. Thus, we can subset our set of SSRN preprints to those related to COVID-19 (to reduce the number of articles), and harvest more accurate publication dates by directly crawling the SSRN website (using the [rvest](https://github.com/tidyverse/rvest) package).

```{r}

getSSRNPublicationDate <- function(doi) {
  
  # Base URL for querying
  base_url <- "https://doi.org/"
  url <- paste0(base_url, doi)
  
  posted_date <- tryCatch({
    # Read page URL and select relevant node
    d <- read_html(url) %>%
      html_nodes("meta[name='citation_online_date'][content]") %>%
      html_attr('content')
    # Sometimes the doi resolves to an empty page - in these cases return NA
    ifelse(length(d), d, NA)
  },
  error = function(e) {
    NA
  })
  return(posted_date)
}

# Create the final SSRN dataset
cr_ssrn_covid <- cr_ssrn_df %>%  
  # Filter COVID-19 related preprints. SSRN metadata does not contain abstracts
  filter(str_detect(title, regex(search_string, ignore_case = TRUE))) %>%
  # Retrieve 'real' posted dates from the SSRN website. Warning: slow
  mutate(posted_date = as.Date(map_chr(doi, getSSRNPublicationDate))) %>%
  # Select relevant fields to keep
  mutate(source = "SSRN") %>%
  select(source, doi, posted_date, title, abstract) %>%
  # Keep only the first preprint where multiple preprints exist with the same title
  group_by(source, title) %>%
  arrange(posted_date) %>%
  slice(1) %>%
  ungroup() %>%
  distinct()
  
```

```{r}

# Merge datasets to get a dataset of all covid-related preprints on Crossref
cr_covid <- bind_rows(cr_posted_content_covid, cr_ssrn_covid)

```

# arXiv data

Another source of preprint metadata is from arXiv, which is not included in Crossref. ArXiv records can be retrieved using the [aRxiv](https://github.com/ropensci/aRxiv) package.

```{r}

# For returning details of preprints on arXiv, we can use the aRxiv package and
# define title and abstract search strings
ar_covid <- arxiv_search('ti:coronavirus OR ti:covid OR ti:sars-cov OR ti:ncov-2019 ti:2019-ncov OR abs:coronavirus OR abs:covid OR abs:sars-cov OR abs:ncov-2019 OR abs:2019-ncov', limit = 10000) %>% 
  mutate(source = "arXiv",
         arxiv_id = id,
         posted_date = as.Date(submitted)) %>%
  filter(posted_date >= as.Date("2020-01-01")) %>%
  select(source, arxiv_id, posted_date, title, abstract) %>%
  distinct()

```

# Create final dataset (bind Crossref and arXiv data)

```{r}

sample_date <- "2020-04-12"

covid_preprints <- bind_rows(cr_covid, ar_covid) %>%
  select(source, doi, arxiv_id, posted_date, title, abstract) %>%
  filter(posted_date <= as.Date(sample_date))

covid_preprints %>%
  write_csv("data/covid19_preprints.csv")

```

# Visualizations

```{r}

# Default theme options
theme_set(theme_minimal() +
          theme(text = element_text(size = 12),
          axis.text.x = element_text(angle = 90, vjust = 0.5),
          axis.title.x = element_text(margin = margin(20, 0, 0, 0)),
          axis.title.y = element_text(margin = margin(0, 20, 0, 0)),
          legend.key.size = unit(0.5, "cm"),
          legend.text = element_text(size = 8),
          plot.caption = element_text(size = 8, color = "darkgrey", 
                                      margin = margin(20, 0, 0, 0))))

```

```{r}

# Repositories with < 10 preprints
other <- covid_preprints %>%
  count(source) %>%
  filter(n < 10) %>%
  pull(source)

# Daily preprint counts
covid_preprints %>%
  mutate(source = case_when(
    source %in% other ~ "Other*",
    T ~ source
  )) %>%
  count(source, posted_date) %>%
  ggplot(aes(x = posted_date, y = n, fill = source)) +
  geom_col() +
  labs(x = "Posted Date", y = "Preprints", fill = "Source",
       title = "COVID-19 preprints per day",
       subtitle = paste0("(up until ", sample_date, ")"),
       caption = paste0("* 'Other' refers to preprint repositories containing ",
                        "<10 relevant preprints. These include: \n",
                        paste(other, collapse = ", "), ".")) +
  scale_x_date(date_breaks = "7 days",
               date_minor_breaks = "1 day",
               expand = c(0.01, 0),
               limits = c(ymd("2020-01-15"), ymd(sample_date)+1)) +
  scale_fill_manual(values = usecol(pal_unikn_pair)) +
  ggsave("outputs/figures/covid19_preprints_day.png", width = 12, height = 6)

```


```{r}

# Weekly preprint counts
covid_preprints %>%
  mutate(
    source = case_when(
      source %in% other ~ "Other*",
      T ~ source
    ),
    posted_week = as.Date(cut(posted_date,
                                   breaks = "week",
                                   start.on.monday = TRUE))) %>%
  count(source, posted_week) %>%
  ggplot(aes(x = posted_week, y = n, fill = source)) +
  geom_col() +
  labs(x = "Posted Date (by week)", y = "Preprints", fill = "Source",
       title = "COVID-19 preprints per week", 
       subtitle = paste0("(up until ", sample_date, ")"),
       caption = paste0("* 'Other' refers to preprint repositories containing ",
                        "<10 relevant preprints. These include: \n",
                        paste(other, collapse = ", "), ".")) +
  scale_x_date(date_breaks = "1 week",
               expand = c(0.01, 0),
               limits = c(ymd("2020-01-13"), ymd(sample_date))) +
  scale_fill_manual(values = usecol(pal_unikn_pair)) +
  ggsave("outputs/figures/covid19_preprints_week.png", width = 12, height = 6)

```

```{r}

# Cumulative daily preprint counts
covid_preprints %>%
  mutate(source = case_when(
      source %in% other ~ "Other*",
      T ~ source
    )) %>%
  count(source, posted_date) %>%
  complete(posted_date, nesting(source), fill = list(n = 0)) %>%
  group_by(source) %>%
  arrange(posted_date) %>%
  mutate(cumulative_n = cumsum(n)) %>%
  ggplot() +
  geom_area(aes(x = posted_date, y = cumulative_n, fill = source)) +
  labs(x = "Posted Date", y = "Preprints", fill = "Source",
       title = "COVID-19 preprints (cumulative)", 
       subtitle = paste0("(up until ", sample_date, ")"),
       caption = paste0("* 'Other' refers to preprint repositories containing ",
                        "<10 relevant preprints. These include: \n",
                        paste(other, collapse = ", "), ".")) +
  scale_y_continuous(labels = scales::comma) +
  scale_x_date(date_breaks = "1 week",
               expand = c(0.01, 0),
               limits = c(ymd("2020-01-13"), ymd(sample_date))) +
  scale_fill_manual(values = usecol(pal_unikn_pair)) +
  theme_minimal() +
  theme(text = element_text(size = 12),
        axis.text.x = element_text(angle = 90, vjust = 0.5),
        axis.title.x = element_text(margin = margin(20, 0, 0, 0)),
        axis.title.y = element_text(margin = margin(0, 20, 0, 0)),
        legend.key.size = unit(0.5, "cm"),
        legend.text = element_text(size = 8),
        plot.caption = element_text(size = 8, color = "darkgrey", margin = margin(20, 0, 0, 0))) +
  ggsave("outputs/figures/covid19_preprints_day_cumulative.png", width = 12, height = 6)

```

